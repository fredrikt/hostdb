#!/usr/local/bin/perl -w
#
# $Id$
#
# script to set mac addresses on hosts in the database based on output of
# cisco command
#
#	terminal length 0
#	sh ip arp
#

use strict;
use Config::IniFiles;
#use lib 'blib/lib';
use HOSTDB;
use Getopt::Std;
use DB_File;
use Fcntl;
use Socket;
use vars qw ($opt_h $opt_d $opt_r $opt_w $opt_f $opt_D);

getopts ('Dhdr:w:f:');

my $debug = defined ($opt_d);
my $dump_db = defined ($opt_D);
my $read_db = defined ($opt_r);
my $write_db = defined ($opt_w);
my @files = @ARGV;
my $default_ttl;
my $filelistfile;

if ($opt_f) {
	$filelistfile = $opt_f;

	open (FIL, "< $opt_f") or die("Could not open file '$filelistfile' for reading: $!\n");

	my $line;
	while ($line = <FIL>) {
		chomp($line);
		push (@files, $line);
	}
	close (FIL);
}

if ($#files == -1 and ! $read_db) {
	die ("Syntax: $0 [options] [cisco-output-file ...]\n" .
	     "	options :\n" .
	     "		-f file		read list of cisco-output-files from file\n" .
	     "		-w cachefile	don't update HOSTDB, write to a hash cache file\n" .
	     "		-r cachefile	read from hash cache file and update HOSTDB\n" .
	     "\n"
	    );
}

if ($filelistfile and $read_db) {
	die ("$0: options -f and -r cannot be used at the same time\n");
}

if ($read_db and $write_db) {
	die ("$0: options -r and -w cannot be used at the same time\n");
}


my $hostdbini = Config::IniFiles->new (-file => HOSTDB::get_inifile ());

my $hostdb = HOSTDB::DB->new (dsn => $hostdbini->val ('db', 'dsn'),
			  db => $hostdbini->val ('db', 'database'),
			  user => $hostdbini->val ('db', 'user'),
			  password => $hostdbini->val ('db', 'password'),
			  debug => $debug
			 );


my (%ip_to_mac, %ip_mac_to_ts, %ip_mac_to_count);

if ($read_db or $write_db) {
	warn ("Tying hashes for reading\n") if ($debug and $read_db);
	warn ("Tying hashes for writing\n") if ($debug and $write_db);

	my $db_cache;
	
	if ($read_db) {
		$db_cache = $opt_r;
	} else {
		$db_cache = $opt_w;
	}

	tie (%ip_to_mac, 'DB_File', "$db_cache-ip_to_mac") or
		die ("$0: Can't open DB hash file '$db_cache-ip_to_mac': $!\n");
	tie (%ip_mac_to_ts, 'DB_File', "$db_cache-ip_mac_to_ts") or
		die ("$0: Can't open DB hash file '$db_cache-ip_mac_to_ts': $!\n");
	tie (%ip_mac_to_count, 'DB_File', "$db_cache-ip_mac_to_count") or
		die ("$0: Can't open DB hash file '$db_cache-ip_mac_to_count': $!\n");
}

if ($filelistfile or $read_db) {
	if ($dump_db) {
		dump_db (\%ip_to_mac, \%ip_mac_to_ts, \%ip_mac_to_count, $debug);
	} else {
		parse_files ($hostdb, \%ip_to_mac, \%ip_mac_to_ts, \%ip_mac_to_count, $debug, @files);
	}
} elsif ($write_db) {
	update_db ($hostdb, \%ip_to_mac, \%ip_mac_to_ts, \%ip_mac_to_count, $debug);	
} else {
	die ("$0: Nothing to do.\n");
}

if ($read_db or $write_db) {
	warn ("Untying hashes\n") if ($debug);
	untie (%ip_to_mac);
	untie (%ip_mac_to_ts);
	untie (%ip_mac_to_count);
}

print ("done\n");


sub parse_files
{
	my $hostdb = shift;
	my $ip_to_mac = shift;
	my $ip_mac_to_ts = shift;
	my $ip_mac_to_count = shift;
	my $debug = shift;
	my @files = @_;

	foreach my $file (@files) {
		open (FIL, "< $file") or warn ("$0: Could not open $file for reading: $!\n"), next;

		my $ts = (stat ($file))[9];

		while (my $rad = <FIL>) {
			chomp ($rad);

			if ($rad =~ /^Internet\s+([0-9\.]+)\s+(\d|\-)+\s+([0-9a-f\.]+)\s+/) {
				my ($ip, $mac) = ($1, $3);
	
				warn ("Invalid MAC address '$3' on $file:$.\n"), next unless $hostdb->clean_mac_address ($mac);

				warn ("IP $ip MAC $mac TS $ts\n") if ($debug);
				my @l;
				@l = split (";", $ip_to_mac->{$ip}) if (defined ($ip_to_mac->{$ip}));
				if (! grep (/^$mac$/, @l)) {
					push (@l, $mac);
					$ip_to_mac->{$ip} = join (";", @l);
				}
				$ip_mac_to_count{"$ip;$mac"}++;
				$ip_mac_to_ts{"$ip;$mac"} = 0 unless defined ($ip_mac_to_ts{"$ip;$mac"});
				$ip_mac_to_ts{"$ip;$mac"} = $ts if ($ts > $ip_mac_to_ts{"$ip;$mac"});
			}
		}
		close (FIL);
		print ("$file\n");
	}
}

sub get_mac
{
	my $ip = shift;
	my $ip_to_mac = shift;
	my $ip_mac_to_ts = shift;
	my $ip_mac_to_count = shift;
	my $debug = shift;
	
	my $r_mac;
	
	my ($mac, $highest_ts);
	$highest_ts = 0;
	foreach $mac (split (";", $ip_to_mac->{$ip})) {
		if ($ip_mac_to_ts->{"$ip;$mac"} > $highest_ts) {
			$highest_ts = $ip_mac_to_ts->{"$ip;$mac"};
			$r_mac = $mac;
		}
	}

	return $r_mac;
}

sub update_db
{
	my $hostdb = shift;
	my $ip_to_mac = shift;
	my $ip_mac_to_ts = shift;
	my $ip_mac_to_count = shift;
	my $debug = shift;
	
	my $total_set_count = 0;
	my $total_failed_count = 0;
	my $total_duplicate_count = 0;
	my $total_ignore_count = 0;

	my ($set_count, $failed_count);
	
	foreach my $ip (keys %$ip_to_mac) {
		my $mac = get_mac ($ip, $ip_to_mac, $ip_mac_to_ts, $ip_mac_to_count, $debug);
		
		my $host = $hostdb->findhostbyip ($ip);
		
		if (! defined ($host->id ())) {
			warn ("$ip not found in database\n");
			$failed_count++;
			$total_failed_count++;
		} else {
			my $valid = 1;

			my $is_dynamic = 1 if ($host->hostname () =~ /^.*dhcp.*/oi);
				
			if ($is_dynamic) {
				printf ("Set IP $ip to dynamic\n");

				$host->mac_address ("") or warn ($host->{error}), $valid = 0;
				$host->dynamic ("Y") or warn ($host->{error}), $valid = 0;

				$host->commit () if ($valid);

				$set_count++;
				$total_set_count++;

				printf ("%-6d %-16s dynamic\n", $total_set_count, $ip);

				next;
			}

			$host->mac_address ($mac) or warn ($host->{error}), $valid = 0;
			if ($valid) {
				$host->commit();
					
				$set_count++;
				$total_set_count++;

				printf ("%-6d %-16s %s\n", $total_set_count, $ip, $mac);
			} else {
				$failed_count++;
				$total_failed_count++;
			}
		}
	}

	print "\n\nTotal statistics:\n",
		"	set:	$total_set_count\n",
		"	failed:	$total_failed_count\n",
		"	dup:	$total_duplicate_count\n",
		"	ign:	$total_ignore_count\n",
		"\n";
}

sub ipsort {
	my ($in1, $in2);
	$in1 = (split(" ", $a))[0];
	$in2 = (split(" ", $b))[0];
	return unpack('N', inet_aton($in1)) <=> unpack('N', inet_aton($in2));
}

sub dump_db
{
	my $ip_to_mac = shift;
	my $ip_mac_to_ts = shift;
	my $ip_mac_to_count = shift;
	my $debug = shift;

	print ("Cache database dump :\n\n");
	
	foreach my $ip (sort ipsort keys %$ip_to_mac) {
		my @mac_l = split (";", $ip_to_mac->{$ip});
		my $count = $#mac_l + 1;
		#next if ($count == 1);
		print ("$ip ($count MACs) :\n");
	
		foreach my $mac (sort { $ip_mac_to_ts->{"$ip;$b"} <=> $ip_mac_to_ts->{"$ip;$a"} } @mac_l) {
			my $ts = localtime ($ip_mac_to_ts->{"$ip;$mac"});
			my $count = $ip_mac_to_count->{"$ip;$mac"};
			
			print ("	$mac	$ts	$count\n");
		}
	}
}
