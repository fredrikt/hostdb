#!/usr/local/bin/perl
#
# $Id$
#
# script to set mac addresses on hosts in the database based on output of
# cisco command
#
#	terminal length 0
#	sh ip arp
#

use strict;
use Config::IniFiles;
#use lib 'blib/lib';
use HOSTDB;
use Getopt::Std;
use NDBM_File;
use Fcntl;
use Socket;
use vars qw ($opt_h $opt_d $opt_r $opt_w $opt_f $opt_D);

getopts ('Dhdr:w:f:');

my $debug = defined ($opt_d);
my $read_mode = 0;
my $write_mode = 0;
my @files = @ARGV;
my $default_ttl;

if ($opt_f) {
	open (FIL, "< $opt_f") or die("Could not open file '$opt_f' for reading: $!\n");

	my $line;
	while ($line = <FIL>) {
		chomp($line);
		push (@files, $line);
	}
	close (FIL);
}

if ($#files == -1 and ! $opt_r) {
	die ("Syntax: $0 [options] [cisco-output-file ...]\n" .
	     "	options :\n" .
	     "		-f file		read list of cisco-output-files from file\n" .
	     "		-w cachefile	don't update HOSTDB, write to a hash cache file\n" .
	     "		-r cachefile	read from hash cache file and update HOSTDB\n" .
	     "\n"
	    );
}

if ($opt_f and $opt_r) {
	die ("$0: options -f and -r cannot be used at the same time\n");
}

if ($opt_r and $opt_w) {
	die ("$0: options -r and -w cannot be used at the same time\n");
}


my $hostdbini = Config::IniFiles->new (-file => HOSTDB::get_inifile ());

my $hostdb = HOSTDB::DB->new (dsn => $hostdbini->val ('db', 'dsn'),
			  db => $hostdbini->val ('db', 'database'),
			  user => $hostdbini->val ('db', 'user'),
			  password => $hostdbini->val ('db', 'password'),
			  debug => $debug
			 );


my (%ip_to_mac, %ip_mac_to_ts, %ip_mac_to_count);

if ($opt_r or $opt_w) {
	my $hf = $opt_r || $opt_w;
	
	tie (%ip_to_mac, "NDBM_File", "$hf-ip_to_mac", O_RDWR|O_CREAT, 0640) or
		die ("$0: Can't open NDBM hash file '$hf-ip_to_mac': $!\n");
	tie (%ip_mac_to_ts, "NDBM_File", "$hf-ip_mac_to_ts", O_RDWR|O_CREAT, 0640) or
		die ("$0: Can't open NDBM hash file '$hf-ip_mac_to_ts': $!\n");
	tie (%ip_mac_to_count, "NDBM_File", "$hf-ip_mac_to_count", O_RDWR|O_CREAT, 0640) or
		die ("$0: Can't open NDBM hash file '$hf-ip_mac_to_count': $!\n");
}

if ($opt_f or $opt_r) {
	if ($opt_D) {
		dump_db (\%ip_to_mac, \%ip_mac_to_ts, \%ip_mac_to_count, $debug);
	} else {
		parse_files ($hostdb, \%ip_to_mac, \%ip_mac_to_ts, \%ip_mac_to_count, $debug, @files);
	}
} elsif ($opt_w) {
	update_db ($hostdb, \%ip_to_mac, \%ip_mac_to_ts, \%ip_mac_to_count, $debug);	
} else {
	die ("$0: Nothing to do.\n");
}

if ($opt_r or $opt_w) {
	untie (%ip_to_mac);
	untie (%ip_mac_to_ts);
	untie (%ip_mac_to_count);
}

print ("done\n");


sub parse_files
{
	my $hostdb = shift;
	my $ip_to_mac = shift;
	my $ip_mac_to_ts = shift;
	my $ip_mac_to_count = shift;
	my $debug = shift;
	my @files = @_;

	foreach my $file (@files) {
		open (FIL, "< $file") or warn ("$0: Could not open $file for reading: $!\n"), next;

		my $ts = (stat ($file))[9];

		while (my $rad = <FIL>) {
			chomp ($rad);

			if ($rad =~ /^Internet\s+([0-9\.]+)\s+(\d|\-)+\s+([0-9a-f\.]+)\s+/) {
				my ($ip, $mac) = ($1, $3);
	
				warn ("Invalid MAC address '$3' on $file:$.\n"), next unless $hostdb->clean_mac_address ($mac);;

				warn ("IP $ip MAC $mac TS $ts\n") if ($debug);
				my @l = split (";", $ip_to_mac->{$ip});
				if (! grep (/^$mac$/, @l)) {
					push (@l, $mac);
					$ip_to_mac->{$ip} = join (";", @l);
				}
				$ip_mac_to_count{"$ip;$mac"}++;
				$ip_mac_to_ts{"$ip;$mac"} = $ts if ($ts > $ip_mac_to_ts{"$ip;$mac"});
			}
		}
		close (FIL);
		print ("$file\n");
	}
}

sub get_mac
{
	my $ip = shift;
	my $ip_to_mac = shift;
	my $ip_mac_to_ts = shift;
	my $ip_mac_to_count = shift;
	my $debug = shift;
	
	my $r_mac;
	
	my ($mac, $highest_ts);
	$highest_ts = 0;
	foreach $mac (split (";", $ip_to_mac->{$ip})) {
		if ($ip_mac_to_ts->{"$ip;$mac"} > $highest_ts) {
			$highest_ts = $ip_mac_to_ts->{"$ip;$mac"};
			$r_mac = $mac;
		}
	}

	return $r_mac;
}

sub update_db
{
	my $hostdb = shift;
	my $ip_to_mac = shift;
	my $ip_mac_to_ts = shift;
	my $ip_mac_to_count = shift;
	my $debug = shift;
	
	my $total_set_count = 0;
	my $total_failed_count = 0;
	my $total_duplicate_count = 0;
	my $total_ignore_count = 0;

	my ($set_count, $failed_count);
	
	foreach my $ip (keys %$ip_to_mac) {
		my $mac = get_mac ($ip, $ip_to_mac, $ip_mac_to_ts, $ip_mac_to_count, $debug);
		
		my $host = $hostdb->findhostbyip ($ip);
		
		if (! defined ($host->id ())) {
			warn ("$ip not found in database\n");
			$failed_count++;
			$total_failed_count++;
		} else {
			my $valid = 1;

			my $is_dynamic = 1 if ($host->hostname () =~ /^.*dhcp.*/oi);
				
			if ($is_dynamic) {
				printf ("Set IP $ip to dynamic\n");

				$host->mac_address ("") or warn ($host->{error}), $valid = 0;
				$host->dynamic ("Y") or warn ($host->{error}), $valid = 0;

				$host->commit () if ($valid);

				$set_count++;
				$total_set_count++;

				printf ("%-6d %-16s dynamic\n", $total_set_count, $ip);

				next;
			}

			$host->mac_address ($mac) or warn ($host->{error}), $valid = 0;
			if ($valid) {
				$host->commit();
					
				$set_count++;
				$total_set_count++;

				printf ("%-6d %-16s %s\n", $total_set_count, $ip, $mac);
			} else {
				$failed_count++;
				$total_failed_count++;
			}
		}
	}

	print ("\n\nTotal statistics:\n",
		"	set:	$total_set_count\n",
		"	failed:	$total_failed_count\n",
		"	dup:	$total_duplicate_count\n",
		"	ign:	$total_ignore_count\n",
		"\n");
}

sub ipsort {
	my ($in1, $in2);
	$in1 = (split(" ", $a))[0];
	$in2 = (split(" ", $b))[0];
	return unpack('N', inet_aton($in1)) <=> unpack('N', inet_aton($in2));
}

sub dump_db
{
	my $ip_to_mac = shift;
	my $ip_mac_to_ts = shift;
	my $ip_mac_to_count = shift;
	my $debug = shift;
	
	foreach my $ip (sort ipsort keys %$ip_to_mac) {
		my @mac_l = split (";", $ip_to_mac->{$ip});
		my $count = $#mac_l + 1;
		#next if ($count == 1);
		print ("$ip ($count MACs) :\n");
	
		foreach my $mac (sort { $ip_mac_to_ts->{"$ip;$b"} <=> $ip_mac_to_ts->{"$ip;$a"} } @mac_l) {
			my $ts = $ip_mac_to_ts->{"$ip;$mac"};
			my $count = $ip_mac_to_count->{"$ip;$mac"};
			
			print ("	$mac	$ts	$count\n");
		}
	}
}
